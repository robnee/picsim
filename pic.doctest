# Doctest

You can use a doctest file to run automated tests that are embedded in documentation or other comments. When you run this file (by tapping the ▷ button), the `doctest` module searches for pieces of text that look like interactive Python sessions, and executes those sessions to verify that they work exactly as shown.

To test multi-line statements, use `...` as the prefix for the additional lines:

    >>> def hello(name):
    ...     return 'Hello ' + name
    >>> hello('World')
    'Hello World'

You can use Markdown formatting (e.g. **bold**, *italic*) in the text surrounding the actual tests. While not strictly required, it is recommended that you indent code blocks (the test cases) with one tab or 4 spaces, so that they are recognized as code when you convert the Markdown to HTML. This also ensures that the code is syntax-highlighted in Pythonista.

You can also run doctests that are contained in actual docstrings of a regular Python file (module). To do that, tap and hold the ▷ button, and select "Run Doctests".

To learn more about doctests, please refer to the `doctest` module documentation.

Due to bugs in Pythonista `os.getcwd` for the project must be added to sys.path
    >>> import os, sys
    >>> sys.path.append(os.getcwd())
    
    >>> import datamem
    >>> d = datamem.DataMem(256, None)

# This test mapping banked addresses to bank/location and linear gpr addresses
    >>> d.translate(0x07)
    (0, 7, None)
    >>> d.translate(0x10)
    (0, 16, None)
    >>> d.translate(0x20)
    (0, 32, 0)
    >>> d.translate(0x50)
    (0, 80, 48)
    >>> d.translate(0x6F)
    (0, 111, 79)
    >>> d.translate(0x75)
    (0, 117, 85)
    >>> d.translate(0xa5)
    (1, 37, 101)
    >>> d.translate(0x125)
    (2, 37, 181)
    >>> d.translate(0x1ff)
    (0, 127, 95)

# tests indirect linear addressing
    >>> d.translate(0x204f)
    (0, 111, 79)
    >>> d.translate(0x2050)
    (1, 32, 96)
    >>> d.translate(0x2055)
    (1, 37, 101)

# test register name addressing storage, retrieval, and dumping
    >>> n = {'X': 0x92, 'Y': 0x95}
    >>> d = datamem.DataMem(256, n)
    >>> d[0x92] = 55
    >>> d['X']
    55
    >>> d['Y'] = d['X']
    >>> d[0x95]
    55
    >>> d.dump(range(0x90, 0x98))
    0090: 00 00 37 00 00 37 00 00 

    >>> print('88 88 ')
    88 88 
    
# Tests encoding instructions
    >>> import pic, insdata
    >>> d = pic.Decoder(insdata.ENHMID)
    >>> d.encode('GOTO', k=0x004).to_bits()
    '10100000000100'
    >>> d.encode('NOP').to_bits()
    '00000000000000'
    >>> d.encode('MOVLW', k=0x10).to_bits()
    '11000000010000'
    >>> d.encode('MOVWF', f=0x30).to_bits()
    '00000010110000'
    >>> d.encode('DECFSZ', d=1, f=0x30).to_bits()
    '00101110110000'
    >>> d.encode('BRA', k=-2 & 0x1ff).to_bits()
    '11001111111110'
    >>> d.encode('CALL', k=0x00A).to_bits()
    '10000000001010'
    >>> d.encode('GOTO', k=0x7FF).to_bits()
    '10111111111111'

# test instruction decoding and formatting
    >>> print(d.decode(0b00000001100001))
    TRIS       0x01
    >>> print(d.decode(0b01100110011101))
    BTFSC      0x1d, 3
    >>> print(d.decode(0b00100110010110))
    COMF       0x16, F
    >>> print(d.decode(0b11111000100101))
    ADDLW      0x25
    >>> print(d.decode(0b11000101011011))
    ADDFSR     FSR1, 0x1b
